---
title: 'Server-side integration'
description: 'Learn how to set up endpoints, request handlers, and the frontend login widget'
---

_As a minimum integration you can implement login workflow, which will automatically redirect an unregistered user to the registration process without your having to explicitly deploy a separate registration page._

## Integration basics

Typically, consuming an API means making RESTful requests to endpoints hosted by a public platform.

Here, your existing web server hosts the endpoints. We provide code templates for each required event handler (see below).

When a user logs in, your frontend generates a login event and upon receiving the event, the OwnID server makes the appropriate HTTP requests to _your_ web server, invoking request handlers provided by OwnID. 

Those request handlers provide the gateway for exchanging keys and data between your frontend and your identity management services. 

## Integration overview

Below are the major steps required to implement login workflow integrated with the OwnID API/SDK. 

<Steps>
  <Step title="PREPARATION">
  _Set up your account, get your application id, and add a field to your user table to store OwnID data._
  </Step>
  <Step title="DROP IN WEB SERVER REQUEST HANDLERS">
  _These three event handlers manage requests to each of three end-points made by the OwnID server when it receives login events from your frontend._    
  </Step>
  <Step title="FRONTEND WORKFLOW">
  _Drop in our HTML and JavaScript templates to build the login workflow and install the widget._  
    
  </Step>
  
</Steps>

The interprocess communication looks like this:
<img
  src="/images/login-diagram.png"
  alt="Widget"
/>
<sup>Figure 1. Requests, responses, and events.</sup>

# Integration steps

The full three step integration process is detailed below.


## 1. Preparation

First create your account in the developer portal.

1. **Set up your account** by logging into the developer console and following the instructions. The console guides you through the process step by step.

2. As part of the sign up process, you'll establish the parameters you need for integration:
<Info>
- Your **account id** - _Use this in data objects where specified_
- Your **application id** - _Use this also in data objects where specified_
- Your **base URL** - _You'll establish this as part of creating your account in the console. OwnID uses this to call endpoints on your backend_
</Info>
3. **Create a VARCHAR field** in your user database and call it `ownIdData`. We'll use this field to store OwnID authentication data. 

<Info>
Be sure the `ownIdData` field meets the following requirements:

- A character datatype e.g., **VARCHAR**
- A minimum length of **5000 chars**
</Info>

## 2. Drop in web server end-points

Below are code templates for the three event handlers needed to implement your server-side endpoints. The OwnID server receives login events from your frontend  then makes HTTP requests to these endpoints. All CRUD-type operations between the OwnID platform and your server use the login id (typically the user email) as the unique identifier in data objects.

Select the tab matching your server-side language in the examples below. 

### Endpoint 1 - Saving a user's OwnIdData Record

This endpoint handles a request to save an OwnIdData record for a given login id, usually email address.

<CodeGroup>

```javascript Node.js
router.post('/setOwnIDDataByLoginId', async (req, res) => {
    const email = req.body.loginId; //The unique id of 
    a user in your database, usually email or phone
    const ownIdData = req.body.ownIdData; //OwnID authentication information as string
    const user = await User.findOne({ email: email }).exec();
    user.ownIdData = ownIdData;
    await user.save();
    return res.sendStatus(204);
//---------------------------------
// these defs can be assumed
const express = require('express'); // If not already imported
const router = express.Router(); // If not already defined

router.post('/setOwnIDDataByLoginId', async (req, res) => {
    try {
        const { loginId, ownIdData } = req.body; // Destructuring for clarity
        
        // Input validation
        if (!loginId || typeof loginId !== 'string' || !ownIdData || typeof ownIdData !== 'string') {
            return res.status(400).json({ error: 'Invalid input data' });
        }
        
        // Find the user by email (assuming loginId is the email)
        const user = await User.findOne({ email: loginId }).exec();
        if (!user) {
            // No user found
            return res.status(404).json({ error: 'User not found' });
        }
        
        // Update the user's ownIdData
        user.ownIdData = ownIdData;
        await user.save();
        
        // Success response
        res.sendStatus(204);
    } catch (error) {
        console.error(error); // Logging the error
        res.status(500).json({ error: 'Internal server error' });
    }
});

module.exports = router; // Is this needed? Maybe too much

});
```
```java Java
@PostMapping("/setOwnIDDataByLoginId")
public ResponseEntity <Object> setOwnIdDataByLoginId(@RequestBody OwnIDData req) {
    User user = userRepository.findByLoginId(req.getLoginId());
    user.setOwnIdData(data);
    userRepository.save(user);

    return ResponseEntity.status(HttpStatus.NO_CONTENT).body(null);
}
```
```csharp C#
[HttpPost("setOwnIDDataByLoginId")]
public async Task<ActionResult<Object>> SetOwnIdDataByLoginId(string loginId, string ownIdData)
{
    var user = _userRepository.Instance.Get(loginId);
    user.ownIdData = ownIdData;
    _userRepository.Instance.Update(user);

    return NoContent();
}
```

```python Python
@app.route('/setOwnIDDataByLoginId', methods=['POST'])
def set_ownid_data_by_login_id():
    data = request.get_json()
    login_id = data['loginId']
    ownid_data = data['ownIdData']
    user = db.session.query(Users).filter(Users.email == login_id).first()
    user.ownid_data = ownid_data
    user.save()
    return ('', 204)
```
</CodeGroup>
<sup>Drop-in request handler for setting an OwnIDData record by user login id. (`setOwnIDDataByLoginId`) </sup>

### Endpoint 2 - Get OwnID data by login id

Handle a request to fetch an OwnIdData record for a given user's email address.

<CodeGroup>

```javascript Node.js
router.post('/getOwnIDDataByLoginId', async (req, res) => {
    const email = req.body.loginId; //The unique id of a user in your database, usually email or phone
    const user = await User.findOne({ email: email }).exec();
    if (!user) { return res.json({ errorCode: 404 }) } //Error code when user doesn't exist
    res.json({ ownIdData: user.ownIdData }) //OwnID authentication information as string
});
```
```java Java
@PostMapping("/getOwnIDDataByLoginId")
public ResponseEntity<Object> getOwnIdDataByLoginId(@RequestBody OwnIDSearchRequest req) {
    User user = userRepository.findByLoginId(req.getLoginId());

    if (user == null) {
        return ResponseEntity.status(HttpStatus.OK).
            body(new OwnIdErrorResponse(HttpStatus.NOT_FOUND, "User not found"));
    }

    return ResponseEntity.status(HttpStatus.OK).body(new OwnIDDataResponse(user.getOwnIdData()));
}
```
```csharp C#
[HttpPost("getOwnIDDataByLoginId")]
public async Task<ActionResult<Object>> GetOwnIDDataByLoginId(string loginId)
{
    var user = _userRepository.Instance.Get(loginId);

    if (user == null)
        return Ok(new { ErrorCode = HttpStatusCode.NotFound, ErrorMessage = "User not found" });

    return Ok(new { OwnIdData = user.OwnIdData });
}
```
```python Python
@app.route('/getOwnIDDataByLoginId', methods=['POST'])
def get_ownid_data_by_login_id():
    data = request.get_json()
    login_id = data['loginId']
    user = db.session.query(Users).filter(Users.email == login_id).first()
    if not user:
        return jsonify({'errorCode': 404})
    return jsonify({'ownidData': user.ownid_data})
```
</CodeGroup>
<sup> Drop-in code for getOwnIDDataByLoginId endpoint</sup>

### Endpoint 3 - Get session by login id

Handle a request to fetch the web token for the current session by user's email address.
<CodeGroup>

```javascript Node.js
router.post('/getSessionByLoginId', async (req, res) => {
    const sign = require('jwt-encode');
    const email = req.body.loginId; //The unique id of a user in your database, usually email or phone
    const user = await User.findOne({ email: email }).exec();
    const jwt = sign({ email: user.email }, 'secret');
    return res.json({ token: jwt });
});
```

```java Java
@PostMapping("/getSessionByLoginId")
public ResponseEntity<OwnIDSessionResponse> getSessionByLoginId(@RequestBody OwnIDSearchRequest req) {
    User user = userRepository.findByLoginId(req.getLoginId());
    Algorithm alg = Algorithm.HMAC256("secret");
    String token = JWT.create().
        withClaim("loginId", req.getLoginId()).
        sign(alg);

    return ResponseEntity.status(HttpStatus.OK).body(new OwnIDSessionResponse(token));
}
```
```csharp C#
[HttpPost("getSessionByLoginId")]
public async Task<ActionResult<OwnIDSessionResponse>> GetSessionByLoginId(string loginId)
{
    var user = _userRepository.Instance.Get(loginId);
    var hashObject = new HMACSHA256(Encoding.UTF8.GetBytes("secret"));
    var signature = hashObject.ComputeHash(Encoding.UTF8.GetBytes(user.LoginId));
    var encodedSignature = Convert.ToBase64String(signature);

    return Ok(new OwnIDSessionResponse() { Token = encodedSignature });
}
```

```python Python
@app.route('/ownid/getSessionByLoginId', methods=['POST'])
def get_session_by_login_id():
    data = request.get_json()
    login_id = data['loginId']
    user = db.session.query(Users).filter(Users.email == login_id).first()
    token = jwt.encode({
        'userId': str(user.email), 'exp': datetime.datetime.utcnow() + datetime.timedelta(hours=3)},
        app.config['SECRET_KEY'],
        "HS256")
    return jsonify({'token': token})
```

</CodeGroup>
<sup> Drop-in code for getOwnIDDataByLoginId endpoint</sup>


## Create Frontend workflow

Referencing the `loginId` input

Placing the widget next to the password field 

<img
  src="/images/oi_widget.png"
  alt="Widget"
/>
<sup>Figure 2. Login widget</sup>

(side-by-side)
Handling password-toggle or password-label elements
Showing errors in your login form

``` javascript
ownid('login', {
          loginIdField: 
          document.getElementById('username'),
          passwordField: 
          document.getElementById('password'),
     passwordToggle:'.show-password-input',
          language:'en',
          onError: (error) => console.log(error),
          onLogin({ token }) { /*see below*/ }
});
```
You don't have to implement an explicit registration workflow because login handles unregistered users. Auto-registration when the account doesn't exist
As part of `/setOwnIDDataByLoginId` endpoint implementation

Establishing the session on `onLogin`

Direct:

```javascript
{ onLogin({ token }) 
  { document.cookie = 
  `sessionId=${token}`; 
  } 
}

Exchange: [when session is an `http-only` cookie]
{ onLogin({ token }) 
  { fetch(`/auth/exchange?token=${token}`); } }
```
Setting a global login handler:
```javascript
ownid('init', { 
    onLogin: ({token}) => {}
})
```

<img
  src="/images/login-diagram.png"
  alt="Widget"
/>

**Install OwnID SDK**

The OwnID Web SDK provides communication between your frontend login page and the OwnID cloud server.

If you're using React or Angular frameworks, install the OwnID SDK from the CLI.

1. To install the React-based SDK:
```javascript reactjs
npm install @ownid/react
```
2. To install the Angular-based SDK:
```javascript angular
npm install @ownid/angular
```


**Initialize OwnID SDK**

<CodeGroup>

```javascript JavaScript
<script>
    ((o,w,n,i,d)=>{o[i]=o[i]||(async(...a)=>((o[i].q=o[i].q||[]).push(a),{error:null,data:null})),
    (d=w.createElement("script")).src='https://cdn.ownid.com/sdk/'+n,d.async=1,w.head.appendChild(d)})  
    (window,document,'<appID>','ownid');
</script>
```

```jsx React
import { OwnIDInit } from '@ownid/react';
<OwnIDInit config={{appId:'9s8d7f9s87g98s7dgMyAppID'}}/>
```

```javascript Angular
import { OwnidAngularModule } from '@ownid/angular';

@NgModule({
  imports: [
    OwnidAngularModule.forRoot({appId:'s9d8f7s98f79s87dfMyAppID'}),
  ]})
```

</CodeGroup>

**Add OwnID button to your login form**

Add the following code to render the login widget:

<CodeGroup>

```javascript javascript
<body>
    <form name="myForm">
        <input id="email" type="text" name="email">
        <input id="password" type="text" name="password">
        <input type="submit" value="Submit">
    </form>
    <script>
        ownid("login", {
            loginIdField: document.getElementById("email"),
            passwordField: document.getElementById("password"),
            onError: (error) => console.log(error),
            onLogin: function (data) {
                 //1. set user session using data.token (usually a jwt or session token), generated in your backend and sent through the OwnID server
                localStorage.setItem('sessionID', JSON.stringify({ token: data.token }));
                //2. redirect the user (this is just an example)
                window.location.href = '/account';
            }
        });
    </script>
</body>
```

```jsx reactjs
function LoginComponent() {
    const emailField = useRef(null);
    const passwordField = useRef(null);
    
    function onLogin(data) {
        //1. set user session using data.token (usually a jwt or session token), generated in your backend and sent through the OwnID server
        localStorage.setItem('sessionID', JSON.stringify({ token: data.token }));
        //2. redirect the user (this is just an example)
        window.location.href = '/account';
    }
    return (
        <form>
            <input ref={emailField} type="email" name="email" />
            <input ref={passwordField} type="password" name="password" />
            <button type="submit">Log In</button>
            <OwnID type='login'
                passwordField={passwordField}
                loginIdField={emailField}
                onError={(error) => console.error(error)}
                onLogin={onLogin} />
        </form>
    );
}
```

```javascript angular
<form #myForm="ngForm" (ngSubmit)="onSubmit()">
  <input #emailField type="email">
  <input #passwordField type="password">
  <ownid type="login"
       [loginIdField]="emailField"
       [passwordField]="passwordField"
       (onLogin)="onLogin($event)">
  </ownid>
  <button type="submit">Log In</button>
</form>

onLogin(data) {
   //1. set user session using data.token (usually a jwt or session token), generated in your backend and sent through the OwnID server
  this.authService.setAuth({ token: data.token });
  //2. redirect the user (this is just an example)
  this.router.navigateByUrl('/account');
}
```


</CodeGroup>


# Handler Reference

### IWidgetConfig

<ParamField query="type" type="WidgetType" default="none" required>
Defines widget type. Determinate flow type.
</ParamField>

<ParamField query="loginType" type="loginType" default="standard" >
Defines login type. Changes flow.
</ParamField>

<ParamField query="promptType" type="promptTypes" default="returning-user">
Used only for prompt widget. Defines prompt type
</ParamField>

<ParamField query="element" type="HTMLElement" default="returning-user">
Used only for prompt widget. Defines prompt type
</ParamField>


<ParamField query="Id" type="string" default="" required>
Widget Id. Used for accessing to widgets entities via owned SDK.
</ParamField>


### IpartialConfig

<ParamField query="appConfig" type="IContextConfig" default="none" required>
Defines app config.
</ParamField>

<ParamField query="language" type="string" default="en">
Defines app’s language. Supported languages list can be checked here: https://github.com/OwnID/localization/blob/develop/translations/langs.json
</ParamField>

<ParamField query="asyncMobileRegistration" type="boolean" default="FALSE">
If set to true, only on mobile, this suppresses the opening of the web-app when clicking on the widget; it is expected to use ownid['getOwnIdData'] on form submission to complete the actual authentication.
[this isn’t relevant to desktop, because we expect the QR to be shown there in the relevant scenario]
</ParamField>

<ParamField query="appId" type="string" default="none">
Application id
</ParamField>

<ParamField query="env" type="string" default="Prod">
Sets sdk’s environment - used to generate the server url.
</ParamField>

<ParamField query="addOrStatement" type="boolean" default="TRUE">
Defines to show “or” statement for the button widget with the targetField.
</ParamField>

<ParamField query="forceRender" type="boolean" default="FALSE">
Can be deprecated and removed. Not used with baking. Defines if widget will be rendered without waiting for its app configuration.
</ParamField>

<ParamField query="ssoUrl" type="string" default="undefined">
ONLY on desktop, If the value is not empty, forces loading the widget in iframe mode, its value as the iframe’s src. This should point to a trusted domain and a path that can serve the relevant page for the “iframe” logic.
</ParamField>

<ParamField query="infoTooltip" type="boolean" default="TRUE">
Defines if info tooltip will be shown or not.
</ParamField>

<ParamField query="infoTooltipPosition" type="Position" default="top">
Sets infoTooltip position relative to the widget
</ParamField>

<ParamField query="mobileInfoTooltipPosition" type="Position" default="top">
Sets infoTooltip position for mobile devices. Overrides infoTooltipPosition value for mobile devices
</ParamField>

<ParamField query="loginIdPattern" type="string" default="none">
When listening to value types into loginIdField, if it matches this pattern then show the info tooltip of the widget.
</ParamField>

<ParamField query="passwordField" type="HTMLInputElement" default="Null">
This field is set as the targetField if it was not set. If the widget is in register type, then onRegister, disable this field. If (passwordFieldBinding) set auto-gen pw as value.
</ParamField>

<ParamField query="loginIdField" type="HTMLInputElement" default="Null">
Sets a field where widget will grab a login id.
</ParamField>

<ParamField query="loginIdPrefixField" type="HTMLInputElement | HTMLSelectElement" default="Null">
Sets a field to get the prefix that will be prepended to the loginId (used for phone numbers, as the country prefix).
</ParamField>

<ParamField query="passwordToggle" type="string" default="undefined">
Css selector for view password toggle button. (For eye buttons) So it can move together with the password field [via setting the element margin].
</ParamField>

<ParamField query="confirmPasswordContainer" type="HTMLElement[] | HTMLElement" default="Null">
Sets the element(s) we’ll hide after the register-widget is done - e.g., where the “confirm password” field is.
</ParamField>

<ParamField query="offset" type="[number, number]" default="[0, 0]">
Defines number of pixel to move widget horizontally and vertically.
</ParamField>

<ParamField query="serverUrl" type="string" default="none">
Sets server’s url. [takes priority over provided appId & env]
</ParamField>

<ParamField query="mobileTitle" type="string" default="none">
ONLY for widget-qr variant, it sets the text on mobile. (Widget from very first implementation. Still supported) [not localizable]
</ParamField>

<ParamField query="title" type="string" default="none">
Sets the button’s text for the widget-button-variants that have one: button, ownid-auth-button, Ownid-auth-button-faceid. [not localizable]
</ParamField>

<ParamField query="desktopTitle" type="string" default="none">
Sets title text for: Widget-qr variant, Widget-button’s QR bubble.
</ParamField>

<ParamField query="desktopSubtitle" type="string" default="none">
Sets title text for: Widget-qr variant. [currently not for the QR bubble]
</ParamField>

<ParamField query="statusInterval"

 type="number" default="500">
Sets interval between status requests when showing the QR. [no min value]
</ParamField>

<ParamField query="variant" type="WidgetVariants" default="button-fingerprint">
Defines widget variant.
</ParamField>

<ParamField query="widgetPosition" type="WidgetPosition" default="start">
Defines widget position according to target field and “direction” style.
</ParamField>

<ParamField query="backgroundColor" type="string" default="none">
Sets background color of the button widgets.
</ParamField>

<ParamField query="textColor" type="string" default="none">
Sets text color of the button widgets. Affects the icon as well.
</ParamField>

<ParamField query="borderColor" type="string" default="none">
Sets border color of the button widgets.
</ParamField>

<ParamField query="boxShadow" type="string" default="none">
Sets shadow of the button widgets with all available properties.
</ParamField>

<ParamField query="redirectUrl" type="string" default="none">
Usually used in the following flow: Native-mobile-app open a webview with our websdk. The widget is being rendered with this param. Usually provided as part of initializing the ownid websdk in gigya’s websdk global conf. When clicking the widget, when the websdk tries to open the web-app, it passes this param value forward to it [ONLY if device param is set to “mobile”]. After a successful authentication, the web-app will redirect to this url. This returns the native-mobile-app back to focus, with the open webview. At this point, the websdk inside the webview will query the context in order to get the session info.
</ParamField>

<ParamField query="redirectUrlOverride" type="object" default="none">
Used for mobile integration to be able to redirect back from browser to mobile app. Overrides redirectUrl according to device.
</ParamField>

<ParamField query="device" type="string" default="none">
If this param holds the “mobile” value, then the redirectUrl is passed to the web-app [see above]. Today, this is only being set in the websdk by the gigya screenset integration.
</ParamField>

<ParamField query="onMagicLink" type="Callback" default="none">
Will be called after a successful magic link authentication - with the session info. [for gigya integration, we hook it ourselves to its onLogin event]
</ParamField>

<ParamField query="onMagicLinkError" type="Callback" default="none">
Will be called after an error when trying to use the magic link, e.g., token expired, wrong browser-instance [missing the server-cookie identifier for the browser initiating the flow]
</ParamField>

<ParamField query="onBeforeLogin" type="async Callback" default="none">
This callback will be called just before onLogin and it will wait for its completion. E.g., if there’s an active gigya integration, it will hook to the onLogin event and set the session on page - so this hook allows you [as a client] to provide a handler that will be called before that.
</ParamField>

<ParamField query="onBeforeRegister" type="async Callback" default="none">
This callback will be called just before onRegister and it will wait for its completion.
</ParamField>

<ParamField query="onBeforeReauth" type="async Callback" default="none">
This callback will be called just before onReauth and it will wait for its completion.
</ParamField>

<ParamField query="onLogin" type="Callback" default="none">
Will be called on ownid successful authentication. If there’s an integration in place, it will first handle the onLogin event in order to establish a frontend session, and only then this callback will be called.
</ParamField>

<ParamField query="onRegister" type="Callback" default="none">
Will be called on ownid success.
</ParamField>

<ParamField query="onReauth" type="Callback" default="none">
Will be called on ownid success.
</ParamField>

<ParamField query="onError" type="Callback" default="none">
Will be called on ownid error - returned from the backend flows.
</ParamField>

<ParamField query="notifyLoginParams" type="Key-value list" default="none">
List of elements will be added to notifyLogin call. Used only for native mobile integration.
</ParamField>

<ParamField query="getAccountInfoParams" type="Key-value list" default="none">
List of elements will be added to getAccountInfo call. Used only for web.
</ParamField>

<ParamField query="firebaseAuth" type="firebaseAuth" default="none">
Sets firebaseAuth for firebase integration [firebase sdk instance].
</ParamField>

<ParamField query="template" type

="string [html]" default="none">
[not in use] Used to set own template for fingerprint button.
</ParamField>

<ParamField query="targetElement" type="HTMLElement" default="none">
Can be deprecated and removed. As we have owned.auth Subscribing to this element “onclick” in order to initiate authentication (used by ownid['customButton'] ) This property takes affect ONLY if the widget variant is “client-button”.
</ParamField>

<ParamField query="targetField" type="HTMLInputElement" default="none">
Sets a field to which widget will be placed next to [according to widgetPosition].
</ParamField>

<ParamField query="promptType" type="PromptTypes" default="returning-user">
Used only for prompt widget. Defines prompt type.
</ParamField>

<ParamField query="checkSession" type="() => boolean | Promise<boolean>" default="none">
Callback for session checker - for IC widget (prompt/modal) Receives default value from gigya & firebase integrations.
</ParamField>

<ParamField query="encrypt" type="(data: string | object) => Promise<string>" default="none">
Encrypt function for secure login id from network transferring.
</ParamField>

<ParamField query="skipFallback" type="boolean" default="FALSE">
If set - skips fallback from primary auth method. By default: Blocks otp if Fido call was unsuccessful.
</ParamField>

<ParamField query="onlyReturningUsers" type="boolean" default="FALSE">
Blocks execution js api call for non returning users.
</ParamField>

<ParamField query="onlyMobile" type="boolean" default="FALSE">
Blocks execution js api call for non mobile users.
</ParamField>

<ParamField query="forceClientWebFlows" type="boolean" default="FALSE">
Forces using webFlows on devices where it was denied by default. (e.q. for webviews)
</ParamField>


## CSS Variables
https://github.com/OwnID/web-sdk/blob/develop/src/components/common/button/button.scss
```css
--ownid-button-height: 42px;
  
--ownid-button-width: 42px;

--ownid-button-widget-font-size: 14px;

--ownid-button-widget-color: #0070F2

--ownid-button-widget-background: #FFFFFF;

--ownid-button-widget-border-color: #D0D0D0;

--ownid-button-widget-border-width: 1px;

--ownid-button-widget-box-shadow: none;

--ownid-button-widget-border-radius: 6px;

--ownid-button-widget-button-padding: 0 4px;

--ownid-qr-or-width: 4px
```

Integration Preparation


# Code samples

- email or login id?
- Import and include libs should be specified?
- Fill in demos with try catches and validation?



## Supported authentication workflow

Three endpoints support all the login and registration scenarios:

- Login

- register

- forgotPassword

- Error handling?

- Security


